
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

export const SUPABASE_URL = "https://hxzcxiaoyndomargozcl.supabase.co";
export const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imh4emN4aWFveW5kb21hcmdvemNsIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDA1OTg3OTAsImV4cCI6MjA1NjE3NDc5MH0.7LitJpGV-XAUQE4i0WIT3PjmxrLD9YlCr3n1COc3ayA";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY);

// Export buckets for direct access
export const CONTENT_FILES_BUCKET = 'content_files';
export const THUMBNAILS_BUCKET = 'thumbnails';

// Export storage for direct access
export const storage = supabase.storage;

// Helper to generate a unique filename while preserving extension
export const generateUniqueFilename = (originalName: string): string => {
  const timestamp = new Date().getTime();
  const randomString = Math.random().toString(36).substring(2, 10);
  const extension = originalName.split('.').pop();
  const baseName = originalName.split('.').slice(0, -1).join('.');
  
  return `${baseName}_${timestamp}_${randomString}.${extension}`;
};

// Helper to check if a file with the same name exists in content table
export const fileExistsInContent = async (originalFilename: string): Promise<boolean> => {
  const { data, error } = await supabase
    .from('content')
    .select('id, original_filename')
    .eq('original_filename', originalFilename)
    .limit(1);
    
  if (error) {
    console.error("Error checking file existence:", error);
    return false;
  }
  
  return data && data.length > 0;
};

// Helper to remove a file from storage
export const removeFileFromStorage = async (
  bucketName: string,
  fileName: string
): Promise<boolean> => {
  try {
    const { error } = await storage
      .from(bucketName)
      .remove([fileName]);
      
    if (error) {
      console.error(`Error removing file from ${bucketName}:`, error);
      return false;
    }
    
    return true;
  } catch (err) {
    console.error(`Exception removing file from ${bucketName}:`, err);
    return false;
  }
};

// Helper to upload a file to storage with overwrite capability
export const uploadFileToStorage = async (
  bucketName: string,
  fileName: string,
  file: File,
  upsert: boolean = false
): Promise<{ url: string | null; error: Error | null }> => {
  try {
    // Attempt to upload the file
    const { error: uploadError } = await storage
      .from(bucketName)
      .upload(fileName, file, { upsert });
      
    // If there's an error and it's not because the file exists, return the error
    if (uploadError && uploadError.message !== 'The resource already exists') {
      return { url: null, error: new Error(`Upload failed: ${uploadError.message}`) };
    }
    
    // If the file exists and upsert is false, try to delete it and re-upload
    if (uploadError && uploadError.message === 'The resource already exists' && !upsert) {
      const removed = await removeFileFromStorage(bucketName, fileName);
      
      if (!removed) {
        return { url: null, error: new Error(`Failed to remove existing file for replacement`) };
      }
      
      // Try upload again after deletion
      const { error: retryError } = await storage
        .from(bucketName)
        .upload(fileName, file, { upsert: false });
        
      if (retryError) {
        return { url: null, error: new Error(`Re-upload failed: ${retryError.message}`) };
      }
    }
    
    // Get the public URL
    const { data: { publicUrl } } = storage
      .from(bucketName)
      .getPublicUrl(fileName);
      
    return { url: publicUrl, error: null };
  } catch (err) {
    return { url: null, error: err instanceof Error ? err : new Error('Unknown error during upload') };
  }
};

// Helper to replace a file in content table
export const replaceContentFile = async (
  originalFilename: string, 
  newContentUrl: string, 
  newThumbnailUrl: string | null,
  contentType: string,
  title: string,
  description: string | null,
  userId: string
): Promise<boolean> => {
  // First, get the existing content record
  const { data: existingContent, error: fetchError } = await supabase
    .from('content')
    .select('*')
    .eq('original_filename', originalFilename)
    .limit(1)
    .single();
  
  if (fetchError) {
    console.error("Error fetching existing content:", fetchError);
    return false;
  }

  // Now update the content record
  const { error: updateError } = await supabase
    .from('content')
    .update({
      content_url: newContentUrl,
      thumbnail_url: newThumbnailUrl,
      content_type: contentType,
      title: title,
      description: description,
      updated_at: new Date().toISOString()
    })
    .eq('id', existingContent.id);
  
  if (updateError) {
    console.error("Error updating content:", updateError);
    return false;
  }
  
  return true;
};
