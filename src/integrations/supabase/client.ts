
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

export const SUPABASE_URL = "https://hxzcxiaoyndomargozcl.supabase.co";
export const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imh4emN4aWFveW5kb21hcmdvemNsIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDA1OTg3OTAsImV4cCI6MjA1NjE3NDc5MH0.7LitJpGV-XAUQE4i0WIT3PjmxrLD9YlCr3n1COc3ayA";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY);

// Export buckets for direct access
export const CONTENT_FILES_BUCKET = 'content_files';
export const THUMBNAILS_BUCKET = 'thumbnails';

// Export storage for direct access
export const storage = supabase.storage;

// Helper to generate a unique filename while preserving extension
export const generateUniqueFilename = (originalName: string): string => {
  const timestamp = new Date().getTime();
  const randomString = Math.random().toString(36).substring(2, 10);
  const extension = originalName.split('.').pop();
  const baseName = originalName.split('.').slice(0, -1).join('.');
  
  return `${baseName}_${timestamp}_${randomString}.${extension}`;
};

// Helper to check if a file with the same name exists in content table
export const fileExistsInContent = async (originalFilename: string): Promise<boolean> => {
  const { data, error } = await supabase
    .from('content')
    .select('id, original_filename')
    .eq('original_filename', originalFilename)
    .limit(1);
    
  if (error) {
    console.error("Error checking file existence:", error);
    return false;
  }
  
  return data && data.length > 0;
};

// Helper to check if URL content already exists in content table
export const urlExistsInContent = async (url: string): Promise<boolean> => {
  const { data, error } = await supabase
    .from('content')
    .select('id, content_url')
    .eq('content_url', url)
    .limit(1);
    
  if (error) {
    console.error("Error checking URL existence:", error);
    return false;
  }
  
  return data && data.length > 0;
};

// Helper to remove a file from storage
export const removeFileFromStorage = async (
  bucketName: string,
  fileName: string
): Promise<boolean> => {
  try {
    const { error } = await storage
      .from(bucketName)
      .remove([fileName]);
      
    if (error) {
      console.error(`Error removing file from ${bucketName}:`, error);
      return false;
    }
    
    return true;
  } catch (err) {
    console.error(`Exception removing file from ${bucketName}:`, err);
    return false;
  }
};

// Helper to upload a file to storage with overwrite capability
export const uploadFileToStorage = async (
  bucketName: string,
  fileName: string,
  file: File,
  upsert: boolean = false
): Promise<{ url: string | null; error: Error | null }> => {
  try {
    // Attempt to upload the file
    const { error: uploadError } = await storage
      .from(bucketName)
      .upload(fileName, file, { upsert });
      
    // If there's an error and it's not because the file exists, return the error
    if (uploadError && uploadError.message !== 'The resource already exists') {
      return { url: null, error: new Error(`Upload failed: ${uploadError.message}`) };
    }
    
    // If the file exists and upsert is false, try to delete it and re-upload
    if (uploadError && uploadError.message === 'The resource already exists' && !upsert) {
      const removed = await removeFileFromStorage(bucketName, fileName);
      
      if (!removed) {
        return { url: null, error: new Error(`Failed to remove existing file for replacement`) };
      }
      
      // Try upload again after deletion
      const { error: retryError } = await storage
        .from(bucketName)
        .upload(fileName, file, { upsert: false });
        
      if (retryError) {
        return { url: null, error: new Error(`Re-upload failed: ${retryError.message}`) };
      }
    }
    
    // Get the public URL
    const { data: { publicUrl } } = storage
      .from(bucketName)
      .getPublicUrl(fileName);
      
    return { url: publicUrl, error: null };
  } catch (err) {
    return { url: null, error: err instanceof Error ? err : new Error('Unknown error during upload') };
  }
};

// Helper to add URL-based content
export const addUrlContent = async (
  contentUrl: string,
  title: string,
  description: string | null,
  contentType: string,
  thumbnailUrl: string | null,
  userId: string,
  categories: string[] = []
): Promise<{ id: string | null; error: Error | null }> => {
  try {
    // Insert content record
    const { data: contentData, error: contentError } = await supabase
      .from('content')
      .insert({
        title: title,
        description: description || null,
        content_type: contentType,
        content_url: contentUrl,
        thumbnail_url: thumbnailUrl,
        created_by: userId,
        is_external_url: true
      })
      .select()
      .single();
      
    if (contentError) {
      console.error("Content database insertion error:", contentError);
      return { id: null, error: new Error(`Failed to save content metadata: ${contentError.message}`) };
    }
    
    // Now add the categories if any are selected
    if (categories.length > 0) {
      const categoryMappings = categories.map(categoryId => ({
        content_id: contentData.id,
        category_id: categoryId
      }));
      
      const { error: categoriesError } = await supabase
        .from('content_categories')
        .insert(categoryMappings);
        
      if (categoriesError) {
        console.error("Error adding categories:", categoriesError);
        // Continue anyway, we've at least added the content
      }
    }
    
    return { id: contentData.id, error: null };
  } catch (err) {
    return { id: null, error: err instanceof Error ? err : new Error('Unknown error adding URL content') };
  }
};

// Helper to replace URL content
export const replaceUrlContent = async (
  existingContentId: string,
  newContentUrl: string, 
  newThumbnailUrl: string | null,
  contentType: string,
  title: string,
  description: string | null,
  categories: string[] = []
): Promise<boolean> => {
  try {
    // Update the content record
    const { error: updateError } = await supabase
      .from('content')
      .update({
        content_url: newContentUrl,
        thumbnail_url: newThumbnailUrl,
        content_type: contentType,
        title: title,
        description: description,
        updated_at: new Date().toISOString(),
        is_external_url: true
      })
      .eq('id', existingContentId);
    
    if (updateError) {
      console.error("Error updating content:", updateError);
      return false;
    }
    
    // Delete existing category associations
    const { error: deleteError } = await supabase
      .from('content_categories')
      .delete()
      .eq('content_id', existingContentId);
      
    if (deleteError) {
      console.error("Error deleting existing categories:", deleteError);
      // Continue anyway to add new categories
    }
    
    // Add new category associations if any
    if (categories.length > 0) {
      const categoryMappings = categories.map(categoryId => ({
        content_id: existingContentId,
        category_id: categoryId
      }));
      
      const { error: insertError } = await supabase
        .from('content_categories')
        .insert(categoryMappings);
        
      if (insertError) {
        console.error("Error adding categories:", insertError);
        // Continue anyway, we've at least updated the content
      }
    }
    
    return true;
  } catch (err) {
    console.error("Error replacing URL content:", err);
    return false;
  }
};

// Helper to replace a file in content table
export const replaceContentFile = async (
  originalFilename: string, 
  newContentUrl: string, 
  newThumbnailUrl: string | null,
  contentType: string,
  title: string,
  description: string | null,
  userId: string
): Promise<boolean> => {
  // First, get the existing content record
  const { data: existingContent, error: fetchError } = await supabase
    .from('content')
    .select('*')
    .eq('original_filename', originalFilename)
    .limit(1)
    .single();
  
  if (fetchError) {
    console.error("Error fetching existing content:", fetchError);
    return false;
  }

  // Now update the content record
  const { error: updateError } = await supabase
    .from('content')
    .update({
      content_url: newContentUrl,
      thumbnail_url: newThumbnailUrl,
      content_type: contentType,
      title: title,
      description: description,
      updated_at: new Date().toISOString(),
      is_external_url: false
    })
    .eq('id', existingContent.id);
  
  if (updateError) {
    console.error("Error updating content:", updateError);
    return false;
  }
  
  return true;
};
